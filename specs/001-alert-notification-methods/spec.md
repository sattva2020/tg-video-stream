# Feature Specification: Способы оповещений (по аналогии с Zabbix)

**Feature Branch**: `001-alert-notification-methods`  
**Created**: 2025-12-10  
**Status**: Draft  
**Input**: User description: "Добавить - Способы оповещений как это реализовано в https://github.com/zabbix/zabbix"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Настройка каналов уведомлений (Priority: P1)

  Администратор подключает необходимые каналы оповещений (email, Telegram-бот, HTTP webhook), задаёт шаблоны и проверяет тестовым отправлением.

  **Why this priority**: Без доступных и проверенных каналов нельзя доставлять события — базовая ценность фичи.

  **Independent Test**: Создать канал каждого типа, настроить шаблон, выполнить «Тест отправки» и убедиться в доставке сообщения с подставленными переменными.

  **Acceptance Scenarios**:

  1. **Given** доступ в панель админа, **When** администратор создаёт канал Email c SMTP-реквизитами и жмёт «Тест отправки», **Then** письмо приходит на указанный адрес с заполненными полями шаблона.
  2. **Given** включён Telegram-бот, **When** администратор добавляет токен и chat_id и жмёт «Тест отправки», **Then** сообщение появляется в чате в течение 10 секунд.
  3. **Given** задан URL webhook, **When** администратор отправляет тест, **Then** целевая система фиксирует корректный JSON-пейлоад и получает ответ 2xx.
### User Story 2 - Маршрутизация и эскалации (Priority: P2)

  Администратор задаёт правила: какие события (severity/теги) доставлять каким получателям и по каким каналам, с резервным каналом при сбое и задержкой эскалации.

  **Why this priority**: Даёт контроль адресности и устойчивости доставки, снижает шум и потери критических оповещений.

  **Independent Test**: Смоделировать событие с заданной серьёзностью и тегами, убедиться, что оно ушло в нужный канал, а при сбое основного канала ушло в резервный спустя таймаут.

  **Acceptance Scenarios**:

  1. **Given** правило «severity=High → команда SRE по Telegram», **When** приходит событие High, **Then** Telegram-адресаты получают сообщение, а остальные каналы не трогаются.
  2. **Given** правило с резервом «email основной, webhook резерв через 30с», **When** SMTP недоступен, **Then** через 30 секунд отправка повторяется через webhook и отмечается в журнале как failover.
### User Story 3 - Снижение шума и обслуживание (Priority: P3)

  Администратор вводит окна тишины/обслуживания и лимиты частоты, чтобы не получать дубликаты и массовый спам при шторме событий.

  **Why this priority**: Контролирует качество оповещений и снижает усталость, особенно при инцидентах.

  **Independent Test**: Настроить окно тишины и rate-limit, сгенерировать пачку событий и убедиться, что в это время уведомления не отправляются либо агрегируются по правилам.

  **Acceptance Scenarios**:

  1. **Given** окно тишины на ночь, **When** событие приходит в это окно, **Then** оно не отправляется, но фиксируется в журнале с пометкой «подавлено».
  2. **Given** лимит 1 сообщение в 5 минут на получателя, **When** приходит 10 одинаковых событий за минуту, **Then** уходит только первое, остальные агрегируются в одно уведомление после окна.
### Edge Cases

  - Неверные/просроченные учётные данные канала (SMTP/бот токен/вебхук) — уведомления не уходят, канал помечается как «ошибка», админ получает сигнал только на альтернативный служебный канал.
  - Недоступен основной канал при боевом событии — должен сработать резерв по таймауту и зафиксироваться как failover.
  - Дедупликация при шторме: 100+ одинаковых событий за минуту не должны превратиться в 100 уведомлений одному адресу.
  - Ограничения получателя: если контакт заблокирован/отписан, отправка пропускает его, но продолжает по остальным адресатам.
  - Шаблон с отсутствующим плейсхолдером — сообщение должно отправиться с пустым значением, но лог содержит предупреждение.

### Список медиа-типов (по аналогии с Zabbix)

- Email (SMTP/STARTTLS)
- Telegram-бот (bot token + chat_id)
- HTTP Webhook (настраиваемый метод/заголовки/тело)
- Slack (incoming webhook)
- Microsoft Teams (incoming webhook)
- Discord (webhook)
- PagerDuty (Events API v2)
- Opsgenie (Events API)
- Pushover (REST)
- SMS/Voice (Twilio либо провайдер через Apprise)
  - **FR-001**: Поддерживать типы каналов: Email (SMTP/STARTTLS), Telegram-бот (token + chat_id), HTTP Webhook (настраиваемый метод/заголовки/тело).
  - **FR-002**: Давать администратору CRUD каналов с валидацией реквизитов и кнопкой «Тест отправки» для каждого типа.
  - **FR-003**: Поддерживать шаблоны сообщений с переменными события (severity, hostname, item, значение, время, ссылка на деталь) и локализацией RU/EN.
  - **FR-004**: Реализовать правила маршрутизации: фильтр по severity/тегам/хостам, адресаты (списки получателей/группы), выбор каналов, порядок и таймаут эскалации.
  - **FR-005**: Обеспечить резервирование: при ошибке основного канала повторить через резервный после таймаута; фиксировать статус (success/fail/failover) в журнале доставки.
  - **FR-006**: Ввести анти-спам: дедупликация идентичных событий за окно, rate-limit per получатель и «окно тишины/maintenance» с указанием временных диапазонов.
  - **FR-007**: Предусмотреть включение/отключение канала и временную блокировку адресата (opt-out) без удаления настроек.
  - **FR-008**: Журналировать каждую попытку доставки (время, канал, получатель, результат, код ответа, latency) и предоставлять фильтр/экспорт.
  - **FR-009**: Предоставить кнопку «Отправить пробное сообщение» из правила для быстрой проверки итоговой маршрутизации.

### Опции надёжности доставки

- Количество попыток и интервал между ними на канал (по аналогии с Zabbix attempts/attempt interval).
- Таймаут на выполнение теста и боевой отправки (frontend ждёт ответ бекенда, бекенд — ответа канала).
- Параллелизм отправки по каналу (concurrent sessions) с очередью при переполнении.
- Failover: порядок каналов, таймаут эскалации, фиксация статуса (success/fail/failover) в журнале.
- Контроль окна активности получателя (when active) и фильтр по severity/тегам/хостам на правило.
  - **NotificationChannel**: экземпляр канала (тип, реквизиты, статус, тест-дата, признак включён/выключен, резервность).
  - **NotificationTemplate**: текст/формат сообщения с плейсхолдерами и языком.
  - **NotificationRule**: условия фильтра (severity, теги, хосты), набор адресатов, порядок каналов, таймауты эскалации, окна тишины, лимиты.
  - **Recipient**: контакт (email, chat_id, webhook URL) и статусы (активен, заблокирован, opt-out).
  - **DeliveryLog**: запись попытки доставки (rule, channel, recipient, результат, длительность, код/ответ).

### Рекомендованный стек (Python/FastAPI)

- Универсальный слой нотификаций: `apprise` (80+ каналов) — базовый адаптер для email/webhook/Slack/Teams/Discord/Pushover/SMS-провайдеров.
- Email: `aiosmtplib` (async SMTP) + Jinja2 шаблоны.
- Telegram: `aiogram` (bot) или `python-telegram-bot` для отправки уведомлений.
- Webhook/REST-интеграции: `httpx` с ретраями и таймаутами.
- Slack/Teams вебхуки: через `httpx` или профильные SDK (`slack_sdk`).
- SMS/Voice: `twilio` SDK либо канал Apprise для совместимых провайдеров.

  - **SC-001**: Администратор настраивает и успешно отправляет тест по каждому типу канала за ≤5 минут без ошибок валидации.
  - **SC-002**: 95% уведомлений по корректным каналам доставляются или фиксируются как failover ≤30 секунд от возникновения события.
  - **SC-003**: Дедупликация/лимиты снижают объём уведомлений при шторме на ≥70% относительно количества событий за тот же период.
  - **SC-004**: Журнал доставки фиксирует 100% попыток с указанием результата и доступен для фильтрации минимум по диапазону дат, каналу и получателю.
