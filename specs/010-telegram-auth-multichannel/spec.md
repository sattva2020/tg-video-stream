# Feature Specification: Telegram Auth & Multichannel

**Feature Branch**: `010-telegram-auth-multichannel`
**Created**: 2025-11-27
**Status**: Draft
**Input**: Implement multi-channel support, local/m3u sources, and interactive Telegram authentication flow.

> ⚖️ Конституция: все текстовые блоки заполняем на русском. Каждая пользовательская история
> должна быть независимой, иметь измеримые критерии успеха и ссылаться на будущие тесты и
> документацию, иначе `/speckit.plan` не пройдет гейт.

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Привязка Telegram аккаунта (Priority: P1)

Как пользователь, я хочу привязать свой Telegram аккаунт через веб-интерфейс, чтобы система могла транслировать контент от моего имени.

**Why this priority**: Это основа для персонализированного вещания. Без привязки аккаунта невозможно управлять каналами пользователя.

**Independent Test**: Можно протестировать процесс авторизации (отправка кода, ввод кода, 2FA) изолированно от стриминга.

**Acceptance Scenarios**:

1.  **Given** Пользователь авторизован в Dashboard, **When** Он вводит номер телефона и нажимает "Получить код", **Then** Бэкенд инициирует процесс входа, и пользователь получает код в Telegram.
2.  **Given** Код отправлен, **When** Пользователь вводит верный код (и пароль, если нужен), **Then** Система сохраняет сессию и отображает статус "Аккаунт подключен".
3.  **Given** Аккаунт подключен, **When** Пользователь нажимает "Отключить", **Then** Сессия удаляется из базы данных.

---

### User Story 2 - Управление каналами (Priority: P1)

Как пользователь, я хочу создавать и настраивать несколько каналов вещания, чтобы транслировать разный контент для разных аудиторий.

**Why this priority**: Реализует ключевое требование мультиканальности.

**Independent Test**: CRUD операции над каналами.

**Acceptance Scenarios**:

1.  **Given** Аккаунт Telegram привязан, **When** Пользователь создает новый канал (указывает ID чата), **Then** Канал сохраняется в системе.
2.  **Given** Канал создан, **When** Пользователь назначает ему индивидуальный плейлист, **Then** Настройки сохраняются и не влияют на другие каналы.

---

### User Story 3 - Поддержка локальных файлов и m3u (Priority: P2)

Как контент-мейкер, я хочу добавлять в плейлист локальные файлы и m3u-списки, чтобы не зависеть только от YouTube.

**Why this priority**: Расширяет возможности вещания.

**Independent Test**: Парсинг m3u и воспроизведение локального файла.

**Acceptance Scenarios**:

1.  **Given** Пользователь загружает m3u файл, **When** Система обрабатывает плейлист, **Then** Элементы списка добавляются в очередь воспроизведения.
2.  **Given** Локальный файл выбран, **When** Стрим доходит до него, **Then** Файл воспроизводится корректно.

---

### User Story 4 - Запуск трансляции (Priority: P1)

Как пользователь, я хочу запускать трансляцию для конкретного канала, чтобы начать эфир.

**Why this priority**: Основная функция системы.

**Independent Test**: Запуск процесса стримера с конкретной конфигурацией.

**Acceptance Scenarios**:

1.  **Given** Канал настроен, **When** Пользователь нажимает "Старт", **Then** Запускается отдельный процесс стримера, использующий сессию пользователя и настройки канала.

## Requirements *(mandatory)*

### Functional Requirements

-   **FR-001**: Система ДОЛЖНА предоставлять API для интерактивной авторизации в Telegram (Send Code, Login, 2FA).
-   **FR-002**: Сессии Telegram ДОЛЖНЫ храниться в базе данных в зашифрованном виде (Symmetric Encryption/Fernet), ключ шифрования хранится в переменной окружения `SESSION_ENCRYPTION_KEY`.
-   **FR-003**: Система ДОЛЖНА поддерживать создание нескольких сущностей "Канал" для одного пользователя.
-   **FR-004**: Каждый канал ДОЛЖЕН иметь свой собственный плейлист и расписание.
-   **FR-005**: Система ДОЛЖНА запускать независимые процессы стриминга для каждого активного канала, используя динамически генерируемые Systemd User Units.
-   **FR-006**: Плейлист ДОЛЖЕН поддерживать ссылки на локальные файлы (строго внутри директории `data/media`) и URL потоков (m3u).

### Architecture Decisions

-   **Process Management**: Использование `systemd --user` для управления процессами стримеров. Бэкенд генерирует `.service` файлы на лету.
-   **Security**: Ключи шифрования сессий хранятся строго в `.env`, сами сессии — в БД.
-   **File Access**: Реализация `chroot`-подобного ограничения доступа к файлам только внутри `data/media` для предотвращения Path Traversal атак.

### Key Entities *(include if feature involves data)*

-   **TelegramAccount**: Привязка к User, хранит encrypted session string, phone, user_id.
-   **Channel**: Привязка к TelegramAccount, хранит chat_id, name, status.
-   **PlaylistItem**: Расширенная модель (type: youtube/local/stream, url/path).

### Edge Cases

-   **Session Expiry**: Если сессия Telegram становится невалидной во время трансляции, стрим должен аварийно остановиться, а статус канала измениться на `AUTH_ERROR`.
-   **File Not Found**: Если локальный файл из плейлиста не найден (удален), система должна пропустить его, залогировать ошибку и перейти к следующему треку.
-   **Systemd Quota**: Если достигнут лимит процессов пользователя, запуск нового канала должен возвращать понятную ошибку (429 Too Many Requests).
-   **Invalid 2FA**: Если пользователь трижды вводит неверный пароль 2FA, процесс авторизации сбрасывается.

## Success Criteria *(mandatory)*

### Measurable Outcomes

-   **SC-001**: Пользователь может привязать аккаунт Telegram (включая 2FA) менее чем за 2 минуты.
-   **SC-002**: Система поддерживает одновременную работу минимум 5 каналов на стандартном сервере (2 vCPU, 4GB RAM).
-   **SC-003**: Время старта трансляции для нового канала не превышает 30 секунд.

## Assumptions

-   Пользователь имеет доступ к файловой системе сервера для загрузки локальных файлов (или будет реализован механизм загрузки через UI в будущем, сейчас - просто путь).
-   Сервер имеет достаточные ресурсы для запуска нескольких экземпляров ffmpeg.

