# Feature Specification: Интеграция компонентов из GitHub-проектов

**Feature Branch**: `016-github-integrations`  
**Created**: 2025-12-01  
**Status**: Draft  
**Input**: Интеграция компонентов из GitHub-проектов: queue из YukkiMusicBot, Flask-Admin из telegram-bot-template, Prometheus мониторинг, WebSocket real-time статистика из monitrix

> ⚖️ Конституция: все текстовые блоки заполняем на русском. Каждая пользовательская история
> должна быть независимой, иметь измеримые критерии успеха и ссылаться на будущие тесты и
> документацию, иначе `/speckit.plan` не пройдет гейт.

## Обзор

Интеграция проверенных паттернов и компонентов из популярных open-source проектов:
- **YukkiMusicBot** (1349⭐) — система очередей и автоматическое завершение стримов
- **telegram-bot-template** (419⭐) — Flask-Admin панель, аналитика, Prometheus
- **monitrix** — WebSocket мониторинг в реальном времени

## User Scenarios & Testing *(mandatory)*

### User Story 1 — Система очередей треков (Priority: P1)

Как администратор стрима, я хочу добавлять треки в очередь воспроизведения, чтобы музыка играла непрерывно без ручного переключения.

**Why this priority**: Очередь — ключевой функционал для непрерывного вещания. Сейчас треки переключаются только вручную, что требует постоянного внимания оператора.

**Independent Test**: Можно протестировать независимо: добавить 5 треков в очередь, запустить воспроизведение, убедиться что треки переключаются автоматически.

**Acceptance Scenarios**:

1. **Given** стрим запущен и плейлист пуст, **When** администратор добавляет 3 трека, **Then** система показывает очередь из 3 элементов с позициями 1, 2, 3
2. **Given** очередь содержит треки, **When** текущий трек заканчивается, **Then** автоматически начинается следующий трек из очереди
3. **Given** очередь из 5 треков, **When** администратор перемещает трек с позиции 4 на позицию 2, **Then** очередь перестраивается и отображает новый порядок
4. **Given** играет трек из очереди, **When** администратор удаляет следующий трек, **Then** трек удаляется без прерывания текущего воспроизведения

---

### User Story 2 — Автоматическое завершение пустого стрима (Priority: P1)

Как система, я должна автоматически завершать стрим, когда в нём нет слушателей определённое время, чтобы экономить ресурсы сервера.

**Why this priority**: Критично для экономии ресурсов. Пустые стримы потребляют CPU/память и могут привести к исчерпанию лимитов Telegram.

**Independent Test**: Запустить стрим без слушателей, подождать настраиваемый таймаут, убедиться что стрим автоматически останавливается.

**Acceptance Scenarios**:

1. **Given** стрим запущен и последний слушатель вышел, **When** проходит 5 минут без слушателей (таймаут по умолчанию), **Then** система автоматически завершает стрим
2. **Given** таймер auto-end активен, **When** новый слушатель подключается, **Then** таймер сбрасывается
3. **Given** администратор настроил таймаут 10 минут, **When** стрим пустеет, **Then** система ждёт ровно 10 минут перед завершением
4. **Given** auto-end отключён в настройках, **When** стрим пустеет, **Then** стрим продолжает работать бесконечно

---

### User Story 3 — Административная панель (Priority: P2)

Как администратор платформы, я хочу управлять пользователями и контентом через веб-интерфейс, чтобы не использовать командную строку.

**Why this priority**: Упрощает администрирование для нетехнических операторов. Текущий функционал ограничен API-эндпоинтами.

**Independent Test**: Войти в админ-панель, просмотреть список пользователей, изменить роль пользователя, убедиться что изменения применились.

**Acceptance Scenarios**:

1. **Given** пользователь с ролью admin, **When** он переходит на /admin, **Then** открывается административная панель с меню навигации
2. **Given** админ в панели пользователей, **When** он ищет пользователя по email, **Then** система показывает найденных пользователей
3. **Given** админ выбрал пользователя, **When** он меняет роль с user на moderator, **Then** роль сохраняется и пользователь получает новые права
4. **Given** админ с ролью moderator, **When** он пытается удалить другого админа, **Then** система отказывает в доступе

---

### User Story 4 — Prometheus мониторинг (Priority: P2)

Как DevOps-инженер, я хочу собирать метрики приложения в Prometheus, чтобы отслеживать производительность и настраивать алерты.

**Why this priority**: Необходимо для production-мониторинга. Позволяет предсказывать проблемы до их возникновения.

**Independent Test**: Запросить /metrics, убедиться что возвращаются метрики в формате Prometheus, добавить в Prometheus и увидеть графики.

**Acceptance Scenarios**:

1. **Given** приложение запущено, **When** Prometheus запрашивает /metrics, **Then** возвращаются метрики в OpenMetrics формате
2. **Given** метрики собираются, **When** происходит 100 запросов к API, **Then** счётчик http_requests_total увеличивается на 100
3. **Given** Grafana подключена к Prometheus, **When** оператор открывает дашборд, **Then** отображаются графики активных стримов, пользователей, latency

---

### User Story 5 — WebSocket мониторинг в реальном времени (Priority: P3)

Как оператор, я хочу видеть статистику стримов в реальном времени на дашборде, чтобы быстро реагировать на проблемы.

**Why this priority**: Улучшает операционный контроль. Текущий WebSocket плейлиста можно расширить до полного мониторинга.

**Independent Test**: Открыть дашборд мониторинга, запустить стрим, убедиться что метрики обновляются без перезагрузки страницы.

**Acceptance Scenarios**:

1. **Given** пользователь на странице мониторинга, **When** новый стрим запускается, **Then** карточка стрима появляется без перезагрузки
2. **Given** стрим активен, **When** слушатель подключается/отключается, **Then** счётчик слушателей обновляется в течение 2 секунд
3. **Given** WebSocket соединение разорвано, **When** сеть восстанавливается, **Then** соединение автоматически переустанавливается

---

### Edge Cases

- Что происходит когда очередь пуста и текущий трек заканчивается? → Система воспроизводит placeholder-заглушку (аудио/видео) в цикле до появления новых треков в очереди
- Как система обрабатывает одновременное добавление треков несколькими админами? → Атомарные операции с очередью, порядок определяется временем получения запроса
- Что если Prometheus недоступен? → Метрики продолжают собираться локально, без влияния на основной функционал
- Как вести себя при потере WebSocket во время критической операции? → Клиент переподключается автоматически, состояние синхронизируется

## Requirements *(mandatory)*

### Functional Requirements

#### Модуль очереди (Queue)
- **FR-001**: Система ДОЛЖНА поддерживать очередь треков с операциями: добавить, удалить, переместить
- **FR-002**: Система ДОЛЖНА автоматически переключаться на следующий трек при завершении текущего
- **FR-003**: Система ДОЛЖНА сохранять состояние очереди при перезапуске (персистентность в Redis)
- **FR-004**: Система ДОЛЖНА поддерживать приоритетное добавление (в начало очереди)

#### Модуль Auto-End
- **FR-005**: Система ДОЛЖНА отслеживать количество слушателей в каждом стриме
- **FR-006**: Система ДОЛЖНА автоматически завершать стрим после настраиваемого таймаута без слушателей
- **FR-007**: Система ДОЛЖНА позволять отключать auto-end для конкретных стримов
- **FR-008**: Система ДОЛЖНА логировать причину завершения стрима (auto-end, manual, error)

#### Административная панель
- **FR-009**: Система ДОЛЖНА предоставлять веб-интерфейс для управления пользователями
- **FR-010**: Система ДОЛЖНА поддерживать CRUD операции для основных сущностей (users, streams, tracks)
- **FR-011**: Система ДОЛЖНА разграничивать доступ к админ-функциям по ролям
- **FR-012**: Система ДОЛЖНА показывать статистику на главной странице админки

#### Prometheus мониторинг
- **FR-013**: Система ДОЛЖНА экспортировать метрики на endpoint /metrics
- **FR-014**: Система ДОЛЖНА собирать метрики: активные стримы, слушатели, запросы, ошибки, latency
- **FR-015**: Метрики ДОЛЖНЫ быть совместимы с Prometheus в формате OpenMetrics

#### WebSocket мониторинг
- **FR-016**: Система ДОЛЖНА транслировать обновления статистики через WebSocket
- **FR-017**: Система ДОЛЖНА поддерживать подписку на конкретные типы событий
- **FR-018**: Система ДОЛЖНА реализовать автоматическое переподключение клиентов

### Key Entities

- **Queue**: Упорядоченная коллекция треков для воспроизведения. Атрибуты: stream_id, items[], current_position
- **QueueItem**: Элемент очереди. Атрибуты: track_id, position, added_by, added_at
- **StreamMetrics**: Агрегированные метрики стрима. Атрибуты: listeners_count, uptime, tracks_played, errors_count
- **AdminAuditLog**: Журнал действий администраторов. Атрибуты: admin_id, action, target, timestamp

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Оператор может добавить 10 треков в очередь менее чем за 30 секунд
- **SC-002**: Автоматическое переключение треков происходит менее чем за 1 секунду после окончания предыдущего
- **SC-003**: Auto-end корректно завершает 100% пустых стримов в пределах заданного таймаута ±10 секунд
- **SC-004**: Административные операции (CRUD пользователей) выполняются менее чем за 2 секунды
- **SC-005**: Система поддерживает 50 одновременных WebSocket соединений без деградации
- **SC-006**: Метрики Prometheus обновляются с интервалом не более 15 секунд
- **SC-007**: WebSocket обновления доставляются клиентам в течение 2 секунд после события

## Assumptions

- Существующая инфраструктура Redis достаточна для хранения очередей
- PyTgCalls предоставляет `on_participants_change` callback для отслеживания слушателей в реальном времени
- Текущая система ролей (admin, moderator, user) достаточна для разграничения доступа к админ-панели
- Grafana будет развёрнута отдельно и подключена к Prometheus
- Frontend использует React и может интегрировать компоненты админ-панели

## Constraints

- Не менять существующий API для обратной совместимости — только расширять
- Использовать SQLAlchemy Admin вместо Flask-Admin (проект на FastAPI)
- Prometheus метрики не должны влиять на latency основных эндпоинтов (>5%)
- WebSocket мониторинг должен использовать существующий механизм (уже есть /api/ws/playlist)

## Clarifications

### Session 2025-12-01
- Q: Что происходит когда очередь пустеет и текущий трек заканчивается? → A: Заглушка (воспроизводить placeholder аудио/видео в цикле до появления треков)
- Q: Как получать количество слушателей стрима в реальном времени? → A: PyTgCalls events (использовать `on_participants_change` callback из PyTgCalls)
- Q: Какой таймаут auto-end использовать по умолчанию? → A: 5 минут (баланс экономии ресурсов и удобства)

## Dependencies

- Redis — для хранения очередей и состояния auto-end
- prometheus_client — Python библиотека для экспорта метрик
- sqladmin — Административная панель для FastAPI + SQLAlchemy
- PyTgCalls — для отслеживания участников голосового чата (on_participants_change callback)
- Существующая WebSocket инфраструктура в backend (`ConnectionManager`)
- Существующий `streamer/queue_manager.py` — расширяем, не создаём заново
- Существующий `backend/src/services/metrics_service.py` — расширяем для Prometheus

## Out of Scope

- Amplitude/PostHog аналитика (не приоритет для MVP)
- Multi-tenant административная панель
- Кастомные Grafana дашборды (будет отдельная задача)
- Миграция существующих плейлистов в новую очередь (ручной процесс)
