# Research: Advanced Audio & Playlist UI

**Feature**: 011-advanced-audio
**Date**: 2024-05-23

## 1. Transcoding Strategy

### Problem
PyTgCalls natively supports raw PCM and Opus. Other formats (FLAC, OGG Vorbis, MP3, etc.) must be transcoded. While PyTgCalls uses FFmpeg internally, explicit handling ensures reliability for diverse formats.

### Findings
- **PyTgCalls `AudioPiped`**: Wraps FFmpeg. It can accept a URL.
- **Mechanism**: When `AudioPiped(path)` is used, it spawns an FFmpeg process that reads `path` and outputs raw PCM to a pipe, which PyTgCalls reads.
- **Constraint**: We need to ensure the FFmpeg command generated by `AudioPiped` is correct for the input format.
- **Solution**: `AudioPiped` is generally sufficient for any format FFmpeg supports. The "Advanced Audio" feature essentially means "Ensure `AudioPiped` is used for audio-only URLs (instead of `AudioVideoPiped` which might expect a video stream) and verify FFmpeg handles the input."
- **Optimization**: For known audio formats (FLAC, OGG), we can explicitly set `HighQualityAudio` parameters.

### Decision
Use `pytgcalls.types.AudioPiped` for all audio-only inputs.
- **Input**: URL or File Path.
- **Parameters**: `AudioPiped(url, audio_parameters=HighQualityAudio())`.
- **Validation**: `audio_utils.detect_content_type` (already implemented) will determine if we use `AudioPiped` (audio) or `AudioVideoPiped` (video).
- **Fallback**: If `AudioPiped` fails, we can construct a custom FFmpeg command and pipe it, but `AudioPiped` is designed for this.

## 2. Backend Playlist Architecture

### Problem
The streamer currently relies on a mock or file-based playlist. We need a robust, persistent playlist managed via API.

### Findings
- **Existing Stack**: FastAPI + SQLAlchemy + PostgreSQL.
- **Requirement**: Persist playlist items.
- **Concurrency**: Streamer reads (polls), User writes (adds/removes).

### Decision
- **Database**: Add `Playlist` model to `backend/src/models/playlist.py`.
  - Fields: `id` (int), `url` (str), `title` (str, optional), `duration` (int, optional), `created_at` (datetime), `status` (enum: queued, playing, played).
- **API**: Add `backend/src/api/v1/endpoints/playlist.py`.
  - `GET /`: List queued items.
  - `POST /`: Add item.
  - `DELETE /{id}`: Remove item.
- **Streamer Integration**: Streamer already polls `GET /api/playlist`. We just need to ensure the response format matches what `streamer/main.py` expects (list of dicts with `url`).

## 3. Frontend UI Integration

### Problem
Users need a visual interface to manage the playlist.

### Findings
- **Existing Stack**: React + Vite + TailwindCSS.
- **Location**: New page `frontend/src/pages/Playlist.tsx`.
- **Routing**: Add route `/playlist` in `frontend/src/App.tsx`.
- **Components**:
  - `PlaylistQueue`: Table/List of items.
  - `AddTrack`: Input form with validation.

### Decision
- Create `Playlist` page.
- Use `fetch` or `axios` to communicate with Backend API.
- Auto-refresh queue every 5-10 seconds to show current status.

## 4. Unknowns & Clarifications

- **Resolved**: Streamer polling mechanism is confirmed.
- **Resolved**: Backend stack is standard FastAPI/PG.
- **Resolved**: Transcoding is handled by `AudioPiped` wrapper around FFmpeg.

